<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Qucs-S S-parameter Viewer &amp; RF Synthesis Tools: attr._next_gen Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../qucs-s.png"/></td>
  <td id="projectalign">
   <div id="projectname">Qucs-S S-parameter Viewer &amp; RF Synthesis Tools
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d1/d69/namespaceattr.html">attr</a></li><li class="navelem"><a class="el" href="../../dd/d37/namespaceattr_1_1__next__gen.html">_next_gen</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">attr._next_gen Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4191e98253bc49e209583246f37a1da4" id="r_a4191e98253bc49e209583246f37a1da4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d37/namespaceattr_1_1__next__gen.html#a4191e98253bc49e209583246f37a1da4">define</a> (maybe_cls=None, *these=None, repr=None, unsafe_hash=None, hash=None, init=None, slots=True, frozen=False, weakref_slot=True, str=False, auto_attribs=None, kw_only=False, cache_hash=False, auto_exc=True, eq=None, order=False, auto_detect=True, getstate_setstate=None, on_setattr=None, field_transformer=None, match_args=True, force_kw_only=False)</td></tr>
<tr class="separator:a4191e98253bc49e209583246f37a1da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313e27992ad6011289f31178234055d0" id="r_a313e27992ad6011289f31178234055d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d37/namespaceattr_1_1__next__gen.html#a313e27992ad6011289f31178234055d0">field</a> (*default=NOTHING, validator=None, repr=True, hash=None, init=True, metadata=None, type=None, converter=None, factory=None, kw_only=None, eq=None, order=None, on_setattr=None, alias=None)</td></tr>
<tr class="separator:a313e27992ad6011289f31178234055d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe1b39dc557485a86ab331fbbbc851a" id="r_aabe1b39dc557485a86ab331fbbbc851a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d37/namespaceattr_1_1__next__gen.html#aabe1b39dc557485a86ab331fbbbc851a">asdict</a> (inst, *recurse=True, filter=None, value_serializer=None)</td></tr>
<tr class="separator:aabe1b39dc557485a86ab331fbbbc851a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b3b77f8db2b8f90eeaa80483010cb5" id="r_a38b3b77f8db2b8f90eeaa80483010cb5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d37/namespaceattr_1_1__next__gen.html#a38b3b77f8db2b8f90eeaa80483010cb5">astuple</a> (inst, *recurse=True, filter=None)</td></tr>
<tr class="separator:a38b3b77f8db2b8f90eeaa80483010cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ed63b2b7b3dac88074ec40e670d547" id="r_a36ed63b2b7b3dac88074ec40e670d547"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d37/namespaceattr_1_1__next__gen.html#a36ed63b2b7b3dac88074ec40e670d547">inspect</a> (cls)</td></tr>
<tr class="separator:a36ed63b2b7b3dac88074ec40e670d547"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a876fb926bd6bb368cb941662919a2fd5" id="r_a876fb926bd6bb368cb941662919a2fd5"><td class="memItemLeft" align="right" valign="top"><a id="a876fb926bd6bb368cb941662919a2fd5" name="a876fb926bd6bb368cb941662919a2fd5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mutable</b> = <a class="el" href="../../dd/d37/namespaceattr_1_1__next__gen.html#a4191e98253bc49e209583246f37a1da4">define</a></td></tr>
<tr class="separator:a876fb926bd6bb368cb941662919a2fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c0efd853025e306c7e59f799e9818b" id="r_a77c0efd853025e306c7e59f799e9818b"><td class="memItemLeft" align="right" valign="top"><a id="a77c0efd853025e306c7e59f799e9818b" name="a77c0efd853025e306c7e59f799e9818b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>frozen</b> = partial(<a class="el" href="../../dd/d37/namespaceattr_1_1__next__gen.html#a4191e98253bc49e209583246f37a1da4">define</a>, frozen=True, on_setattr=None)</td></tr>
<tr class="separator:a77c0efd853025e306c7e59f799e9818b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">These are keyword-only APIs that call `attr.s` and `attr.ib` with different
default values.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="aabe1b39dc557485a86ab331fbbbc851a" name="aabe1b39dc557485a86ab331fbbbc851a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe1b39dc557485a86ab331fbbbc851a">&#9670;&#160;</a></span>asdict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attr._next_gen.asdict </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>recurse</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filter</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value_serializer</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Same as `attr.asdict`, except that collections types are always retained
and dict is always used as *dict_factory*.

.. versionadded:: 21.3.0
</pre> 
</div>
</div>
<a id="a38b3b77f8db2b8f90eeaa80483010cb5" name="a38b3b77f8db2b8f90eeaa80483010cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b3b77f8db2b8f90eeaa80483010cb5">&#9670;&#160;</a></span>astuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attr._next_gen.astuple </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>recurse</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filter</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Same as `attr.astuple`, except that collections types are always retained
and `tuple` is always used as the *tuple_factory*.

.. versionadded:: 21.3.0
</pre> 
</div>
</div>
<a id="a4191e98253bc49e209583246f37a1da4" name="a4191e98253bc49e209583246f37a1da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4191e98253bc49e209583246f37a1da4">&#9670;&#160;</a></span>define()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attr._next_gen.define </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maybe_cls</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>these</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>repr</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>unsafe_hash</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hash</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>init</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>slots</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>frozen</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weakref_slot</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>str</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>auto_attribs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kw_only</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cache_hash</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>auto_exc</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>auto_detect</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>getstate_setstate</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>on_setattr</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>field_transformer</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>match_args</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>force_kw_only</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">    A class decorator that adds :term:`dunder methods` according to
    :term:`fields &lt;field&gt;` specified using :doc:`type annotations &lt;types&gt;`,
    `field()` calls, or the *these* argument.

    Since *attrs* patches or replaces an existing class, you cannot use
    `object.__init_subclass__` with *attrs* classes, because it runs too early.
    As a replacement, you can define ``__attrs_init_subclass__`` on your class.
    It will be called by *attrs* classes that subclass it after they're
    created. See also :ref:`init-subclass`.

    Args:
        slots (bool):
            Create a :term:`slotted class &lt;slotted classes&gt;` that's more
            memory-efficient. Slotted classes are generally superior to the
            default dict classes, but have some gotchas you should know about,
            so we encourage you to read the :term:`glossary entry &lt;slotted
            classes&gt;`.

        auto_detect (bool):
            Instead of setting the *init*, *repr*, *eq*, and *hash* arguments
            explicitly, assume they are set to True **unless any** of the
            involved methods for one of the arguments is implemented in the
            *current* class (meaning, it is *not* inherited from some base
            class).

            So, for example by implementing ``__eq__`` on a class yourself,
            *attrs* will deduce ``eq=False`` and will create *neither*
            ``__eq__`` *nor* ``__ne__`` (but Python classes come with a
            sensible ``__ne__`` by default, so it *should* be enough to only
            implement ``__eq__`` in most cases).

            Passing :data:`True` or :data:`False` to *init*, *repr*, *eq*, or *hash*
            overrides whatever *auto_detect* would determine.

        auto_exc (bool):
            If the class subclasses `BaseException` (which implicitly includes
            any subclass of any exception), the following happens to behave
            like a well-behaved Python exception class:

            - the values for *eq*, *order*, and *hash* are ignored and the
              instances compare and hash by the instance's ids [#]_ ,
            - all attributes that are either passed into ``__init__`` or have a
              default value are additionally available as a tuple in the
              ``args`` attribute,
            - the value of *str* is ignored leaving ``__str__`` to base
              classes.

            .. [#]
               Note that *attrs* will *not* remove existing implementations of
               ``__hash__`` or the equality methods. It just won't add own
               ones.

        on_setattr (~typing.Callable | list[~typing.Callable] | None | ~typing.Literal[attrs.setters.NO_OP]):
            A callable that is run whenever the user attempts to set an
            attribute (either by assignment like ``i.x = 42`` or by using
            `setattr` like ``setattr(i, "x", 42)``). It receives the same
            arguments as validators: the instance, the attribute that is being
            modified, and the new value.

            If no exception is raised, the attribute is set to the return value
            of the callable.

            If a list of callables is passed, they're automatically wrapped in
            an `attrs.setters.pipe`.

            If left None, the default behavior is to run converters and
            validators whenever an attribute is set.

        init (bool):
            Create a ``__init__`` method that initializes the *attrs*
            attributes. Leading underscores are stripped for the argument name,
            unless an alias is set on the attribute.

            .. seealso::
                `init` shows advanced ways to customize the generated
                ``__init__`` method, including executing code before and after.

        repr(bool):
            Create a ``__repr__`` method with a human readable representation
            of *attrs* attributes.

        str (bool):
            Create a ``__str__`` method that is identical to ``__repr__``. This
            is usually not necessary except for `Exception`\ s.

        eq (bool | None):
            If True or None (default), add ``__eq__`` and ``__ne__`` methods
            that check two instances for equality.

            .. seealso::
                `comparison` describes how to customize the comparison behavior
                going as far comparing NumPy arrays.

        order (bool | None):
            If True, add ``__lt__``, ``__le__``, ``__gt__``, and ``__ge__``
            methods that behave like *eq* above and allow instances to be
            ordered.

            They compare the instances as if they were tuples of their *attrs*
            attributes if and only if the types of both classes are
            *identical*.

            If `None` mirror value of *eq*.

            .. seealso:: `comparison`

        unsafe_hash (bool | None):
            If None (default), the ``__hash__`` method is generated according
            how *eq* and *frozen* are set.

            1. If *both* are True, *attrs* will generate a ``__hash__`` for
               you.
            2. If *eq* is True and *frozen* is False, ``__hash__`` will be set
               to None, marking it unhashable (which it is).
            3. If *eq* is False, ``__hash__`` will be left untouched meaning
               the ``__hash__`` method of the base class will be used. If the
               base class is `object`, this means it will fall back to id-based
               hashing.

            Although not recommended, you can decide for yourself and force
            *attrs* to create one (for example, if the class is immutable even
            though you didn't freeze it programmatically) by passing True or
            not.  Both of these cases are rather special and should be used
            carefully.

            .. seealso::

                - Our documentation on `hashing`,
                - Python's documentation on `object.__hash__`,
                - and the `GitHub issue that led to the default \ behavior
                  &lt;https://github.com/python-attrs/attrs/issues/136&gt;`_ for more
                  details.

        hash (bool | None):
            Deprecated alias for *unsafe_hash*. *unsafe_hash* takes precedence.

        cache_hash (bool):
            Ensure that the object's hash code is computed only once and stored
            on the object.  If this is set to True, hashing must be either
            explicitly or implicitly enabled for this class.  If the hash code
            is cached, avoid any reassignments of fields involved in hash code
            computation or mutations of the objects those fields point to after
            object creation.  If such changes occur, the behavior of the
            object's hash code is undefined.

        frozen (bool):
            Make instances immutable after initialization.  If someone attempts
            to modify a frozen instance, `attrs.exceptions.FrozenInstanceError`
            is raised.

            .. note::

                1. This is achieved by installing a custom ``__setattr__``
                   method on your class, so you can't implement your own.

                2. True immutability is impossible in Python.

                3. This *does* have a minor a runtime performance `impact
                   &lt;how-frozen&gt;` when initializing new instances.  In other
                   words: ``__init__`` is slightly slower with ``frozen=True``.

                4. If a class is frozen, you cannot modify ``self`` in
                   ``__attrs_post_init__`` or a self-written ``__init__``. You
                   can circumvent that limitation by using
                   ``object.__setattr__(self, "attribute_name", value)``.

                5. Subclasses of a frozen class are frozen too.

        kw_only (bool):
            Make attributes keyword-only in the generated ``__init__`` (if
            *init* is False, this parameter is ignored).  Attributes that
            explicitly set ``kw_only=False`` are not affected; base class
            attributes are also not affected.

            Also see *force_kw_only*.

        weakref_slot (bool):
            Make instances weak-referenceable.  This has no effect unless
            *slots* is True.

        field_transformer (~typing.Callable | None):
            A function that is called with the original class object and all
            fields right before *attrs* finalizes the class.  You can use this,
            for example, to automatically add converters or validators to
            fields based on their types.

            .. seealso:: `transform-fields`

        match_args (bool):
            If True (default), set ``__match_args__`` on the class to support
            :pep:`634` (*Structural Pattern Matching*). It is a tuple of all
            non-keyword-only ``__init__`` parameter names on Python 3.10 and
            later. Ignored on older Python versions.

        collect_by_mro (bool):
            If True, *attrs* collects attributes from base classes correctly
            according to the `method resolution order
            &lt;https://docs.python.org/3/howto/mro.html&gt;`_. If False, *attrs*
            will mimic the (wrong) behavior of `dataclasses` and :pep:`681`.

            See also `issue #428
            &lt;https://github.com/python-attrs/attrs/issues/428&gt;`_.

        force_kw_only (bool):
            A back-compat flag for restoring pre-25.4.0 behavior.  If True and
            ``kw_only=True``, all attributes are made keyword-only, including
            base class attributes, and those set to ``kw_only=False`` at the
            attribute level.  Defaults to False.

            See also `issue #980
            &lt;https://github.com/python-attrs/attrs/issues/980&gt;`_.

        getstate_setstate (bool | None):
            .. note::

                This is usually only interesting for slotted classes and you
                should probably just set *auto_detect* to True.

            If True, ``__getstate__`` and ``__setstate__`` are generated and
            attached to the class. This is necessary for slotted classes to be
            pickleable. If left None, it's True by default for slotted classes
            and False for dict classes.

            If *auto_detect* is True, and *getstate_setstate* is left None, and
            **either** ``__getstate__`` or ``__setstate__`` is detected
            directly on the class (meaning: not inherited), it is set to False
            (this is usually what you want).

        auto_attribs (bool | None):
            If True, look at type annotations to determine which attributes to
            use, like `dataclasses`. If False, it will only look for explicit
            :func:`field` class attributes, like classic *attrs*.

            If left None, it will guess:

            1. If any attributes are annotated and no unannotated
               `attrs.field`\ s are found, it assumes *auto_attribs=True*.
            2. Otherwise it assumes *auto_attribs=False* and tries to collect
               `attrs.field`\ s.

            If *attrs* decides to look at type annotations, **all** fields
            **must** be annotated. If *attrs* encounters a field that is set to
            a :func:`field` / `attr.ib` but lacks a type annotation, an
            `attrs.exceptions.UnannotatedAttributeError` is raised.  Use
            ``field_name: typing.Any = field(...)`` if you don't want to set a
            type.

            .. warning::

                For features that use the attribute name to create decorators
                (for example, :ref:`validators &lt;validators&gt;`), you still *must*
                assign :func:`field` / `attr.ib` to them. Otherwise Python will
                either not find the name or try to use the default value to
                call, for example, ``validator`` on it.

            Attributes annotated as `typing.ClassVar`, and attributes that are
            neither annotated nor set to an `field()` are **ignored**.

        these (dict[str, object]):
            A dictionary of name to the (private) return value of `field()`
            mappings. This is useful to avoid the definition of your attributes
            within the class body because you can't (for example, if you want
            to add ``__repr__`` methods to Django models) or don't want to.

            If *these* is not `None`, *attrs* will *not* search the class body
            for attributes and will *not* remove any attributes from it.

            The order is deduced from the order of the attributes inside
            *these*.

            Arguably, this is a rather obscure feature.

    .. versionadded:: 20.1.0
    .. versionchanged:: 21.3.0 Converters are also run ``on_setattr``.
    .. versionadded:: 22.2.0
       *unsafe_hash* as an alias for *hash* (for :pep:`681` compliance).
    .. versionchanged:: 24.1.0
       Instances are not compared as tuples of attributes anymore, but using a
       big ``and`` condition. This is faster and has more correct behavior for
       uncomparable values like `math.nan`.
    .. versionadded:: 24.1.0
       If a class has an *inherited* classmethod called
       ``__attrs_init_subclass__``, it is executed after the class is created.
    .. deprecated:: 24.1.0 *hash* is deprecated in favor of *unsafe_hash*.
    .. versionadded:: 24.3.0
       Unless already present, a ``__replace__`` method is automatically
       created for `copy.replace` (Python 3.13+ only).
    .. versionchanged:: 25.4.0
       *kw_only* now only applies to attributes defined in the current class,
       and respects attribute-level ``kw_only=False`` settings.
    .. versionadded:: 25.4.0
       Added *force_kw_only* to go back to the previous *kw_only* behavior.

    .. note::

        The main differences to the classic `attr.s` are:

        - Automatically detect whether or not *auto_attribs* should be `True`
          (c.f. *auto_attribs* parameter).
        - Converters and validators run when attributes are set by default --
          if *frozen* is `False`.
        - *slots=True*

          Usually, this has only upsides and few visible effects in everyday
          programming. But it *can* lead to some surprising behaviors, so
          please make sure to read :term:`slotted classes`.

        - *auto_exc=True*
        - *auto_detect=True*
        - *order=False*
        - *force_kw_only=False*
        - Some options that were only relevant on Python 2 or were kept around
          for backwards-compatibility have been removed.</pre> 
</div>
</div>
<a id="a313e27992ad6011289f31178234055d0" name="a313e27992ad6011289f31178234055d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313e27992ad6011289f31178234055d0">&#9670;&#160;</a></span>field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attr._next_gen.field </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>default</em> = <code>NOTHING</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>validator</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>repr</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hash</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>init</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>type</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>converter</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>factory</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kw_only</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>on_setattr</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alias</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a new :term:`field` / :term:`attribute` on a class.

..  warning::

    Does **nothing** unless the class is also decorated with
    `attrs.define` (or similar)!

Args:
    default:
        A value that is used if an *attrs*-generated ``__init__`` is used
        and no value is passed while instantiating or the attribute is
        excluded using ``init=False``.

        If the value is an instance of `attrs.Factory`, its callable will
        be used to construct a new value (useful for mutable data types
        like lists or dicts).

        If a default is not set (or set manually to `attrs.NOTHING`), a
        value *must* be supplied when instantiating; otherwise a
        `TypeError` will be raised.

        .. seealso:: `defaults`

    factory (~typing.Callable):
        Syntactic sugar for ``default=attr.Factory(factory)``.

    validator (~typing.Callable | list[~typing.Callable]):
        Callable that is called by *attrs*-generated ``__init__`` methods
        after the instance has been initialized.  They receive the
        initialized instance, the :func:`~attrs.Attribute`, and the passed
        value.

        The return value is *not* inspected so the validator has to throw
        an exception itself.

        If a `list` is passed, its items are treated as validators and must
        all pass.

        Validators can be globally disabled and re-enabled using
        `attrs.validators.get_disabled` / `attrs.validators.set_disabled`.

        The validator can also be set using decorator notation as shown
        below.

        .. seealso:: :ref:`validators`

    repr (bool | ~typing.Callable):
        Include this attribute in the generated ``__repr__`` method. If
        True, include the attribute; if False, omit it. By default, the
        built-in ``repr()`` function is used. To override how the attribute
        value is formatted, pass a ``callable`` that takes a single value
        and returns a string. Note that the resulting string is used as-is,
        which means it will be used directly *instead* of calling
        ``repr()`` (the default).

    eq (bool | ~typing.Callable):
        If True (default), include this attribute in the generated
        ``__eq__`` and ``__ne__`` methods that check two instances for
        equality. To override how the attribute value is compared, pass a
        callable that takes a single value and returns the value to be
        compared.

        .. seealso:: `comparison`

    order (bool | ~typing.Callable):
        If True (default), include this attributes in the generated
        ``__lt__``, ``__le__``, ``__gt__`` and ``__ge__`` methods. To
        override how the attribute value is ordered, pass a callable that
        takes a single value and returns the value to be ordered.

        .. seealso:: `comparison`

    hash (bool | None):
        Include this attribute in the generated ``__hash__`` method.  If
        None (default), mirror *eq*'s value.  This is the correct behavior
        according the Python spec.  Setting this value to anything else
        than None is *discouraged*.

        .. seealso:: `hashing`

    init (bool):
        Include this attribute in the generated ``__init__`` method.

        It is possible to set this to False and set a default value. In
        that case this attributed is unconditionally initialized with the
        specified default value or factory.

        .. seealso:: `init`

    converter (typing.Callable | Converter):
        A callable that is called by *attrs*-generated ``__init__`` methods
        to convert attribute's value to the desired format.

        If a vanilla callable is passed, it is given the passed-in value as
        the only positional argument. It is possible to receive additional
        arguments by wrapping the callable in a `Converter`.

        Either way, the returned value will be used as the new value of the
        attribute.  The value is converted before being passed to the
        validator, if any.

        .. seealso:: :ref:`converters`

    metadata (dict | None):
        An arbitrary mapping, to be used by third-party code.

        .. seealso:: `extending-metadata`.

    type (type):
        The type of the attribute. Nowadays, the preferred method to
        specify the type is using a variable annotation (see :pep:`526`).
        This argument is provided for backwards-compatibility and for usage
        with `make_class`. Regardless of the approach used, the type will
        be stored on ``Attribute.type``.

        Please note that *attrs* doesn't do anything with this metadata by
        itself. You can use it as part of your own code or for `static type
        checking &lt;types&gt;`.

    kw_only (bool | None):
        Make this attribute keyword-only in the generated ``__init__`` (if
        *init* is False, this parameter is ignored).  If None (default),
        mirror the setting from `attrs.define`.

    on_setattr (~typing.Callable | list[~typing.Callable] | None | ~typing.Literal[attrs.setters.NO_OP]):
        Allows to overwrite the *on_setattr* setting from `attr.s`. If left
        None, the *on_setattr* value from `attr.s` is used. Set to
        `attrs.setters.NO_OP` to run **no** `setattr` hooks for this
        attribute -- regardless of the setting in `define()`.

    alias (str | None):
        Override this attribute's parameter name in the generated
        ``__init__`` method. If left None, default to ``name`` stripped
        of leading underscores. See `private-attributes`.

.. versionadded:: 20.1.0
.. versionchanged:: 21.1.0
   *eq*, *order*, and *cmp* also accept a custom callable
.. versionadded:: 22.2.0 *alias*
.. versionadded:: 23.1.0
   The *type* parameter has been re-added; mostly for `attrs.make_class`.
   Please note that type checkers ignore this metadata.
.. versionchanged:: 25.4.0
   *kw_only* can now be None, and its default is also changed from False to
   None.

.. seealso::

   `attr.ib`
</pre> 
</div>
</div>
<a id="a36ed63b2b7b3dac88074ec40e670d547" name="a36ed63b2b7b3dac88074ec40e670d547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ed63b2b7b3dac88074ec40e670d547">&#9670;&#160;</a></span>inspect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attr._next_gen.inspect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Inspect the class and return its effective build parameters.

Warning:
    This feature is currently **experimental** and is not covered by our
    strict backwards-compatibility guarantees.

Args:
    cls: The *attrs*-decorated class to inspect.

Returns:
    The effective build parameters of the class.

Raises:
    NotAnAttrsClassError: If the class is not an *attrs*-decorated class.

.. versionadded:: 25.4.0
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
