<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Qucs-S S-parameter Viewer &amp; RF Synthesis Tools: babel.messages.extract Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../qucs-s.png"/></td>
  <td id="projectalign">
   <div id="projectname">Qucs-S S-parameter Viewer &amp; RF Synthesis Tools
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d0/da3/namespacebabel.html">babel</a></li><li class="navelem"><a class="el" href="../../d2/d79/namespacebabel_1_1messages.html">messages</a></li><li class="navelem"><a class="el" href="../../d8/d0f/namespacebabel_1_1messages_1_1extract.html">extract</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">babel.messages.extract Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d59/classbabel_1_1messages_1_1extract_1_1__FileObj.html">_FileObj</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d8a/classbabel_1_1messages_1_1extract_1_1__JSOptions.html">_JSOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d69/classbabel_1_1messages_1_1extract_1_1__PyOptions.html">_PyOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aed7e3a204b2e7b83645eb164c83ce324" id="r_aed7e3a204b2e7b83645eb164c83ce324"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d0f/namespacebabel_1_1messages_1_1extract.html#aed7e3a204b2e7b83645eb164c83ce324">_strip_comment_tags</a> (MutableSequence[str] comments, Iterable[str] tags)</td></tr>
<tr class="separator:aed7e3a204b2e7b83645eb164c83ce324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f34bf22e8dafe89b39274819b6ee73a" id="r_a7f34bf22e8dafe89b39274819b6ee73a"><td class="memItemLeft" align="right" valign="top"><a id="a7f34bf22e8dafe89b39274819b6ee73a" name="a7f34bf22e8dafe89b39274819b6ee73a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>default_directory_filter</b> (str|os.PathLike[str] dirpath)</td></tr>
<tr class="separator:a7f34bf22e8dafe89b39274819b6ee73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad058b4dfa640166376e8560b0fcbcb3b" id="r_ad058b4dfa640166376e8560b0fcbcb3b"><td class="memItemLeft" align="right" valign="top">Generator[_FileExtractionResult, None, None]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d0f/namespacebabel_1_1messages_1_1extract.html#ad058b4dfa640166376e8560b0fcbcb3b">extract_from_dir</a> (str|os.PathLike[str]|None dirname=None, Iterable[tuple[str, str]] method_map=DEFAULT_MAPPING, SupportsItems[str, dict[str, Any]]|None options_map=None, Mapping[str, _Keyword] keywords=DEFAULT_KEYWORDS, Collection[str] comment_tags=(), Callable[[str, str, dict[str, Any]], object]|None callback=None, bool strip_comment_tags=False, Callable[[str], bool]|None directory_filter=None)</td></tr>
<tr class="separator:ad058b4dfa640166376e8560b0fcbcb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b58e48d2db9b0c09ba8d7144d65f82" id="r_a34b58e48d2db9b0c09ba8d7144d65f82"><td class="memItemLeft" align="right" valign="top">Generator[_FileExtractionResult, None, None]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d0f/namespacebabel_1_1messages_1_1extract.html#a34b58e48d2db9b0c09ba8d7144d65f82">check_and_call_extract_file</a> (str|os.PathLike[str] filepath, Iterable[tuple[str, str]] method_map, SupportsItems[str, dict[str, Any]] options_map, Callable[[str, str, dict[str, Any]], object]|None callback, Mapping[str, _Keyword] keywords, Collection[str] comment_tags, bool strip_comment_tags, str|os.PathLike[str]|None dirpath=None)</td></tr>
<tr class="separator:a34b58e48d2db9b0c09ba8d7144d65f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862f8e2ef602348b174346a22e9fc89e" id="r_a862f8e2ef602348b174346a22e9fc89e"><td class="memItemLeft" align="right" valign="top">list[_ExtractionResult]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d0f/namespacebabel_1_1messages_1_1extract.html#a862f8e2ef602348b174346a22e9fc89e">extract_from_file</a> (_ExtractionMethod method, str|os.PathLike[str] filename, Mapping[str, _Keyword] keywords=DEFAULT_KEYWORDS, Collection[str] comment_tags=(), Mapping[str, Any]|None options=None, bool strip_comment_tags=False)</td></tr>
<tr class="separator:a862f8e2ef602348b174346a22e9fc89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b3ccc006cf228109406e3f3087032c" id="r_ae4b3ccc006cf228109406e3f3087032c"><td class="memItemLeft" align="right" valign="top"><a id="ae4b3ccc006cf228109406e3f3087032c" name="ae4b3ccc006cf228109406e3f3087032c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>_match_messages_against_spec</b> (int lineno, list[str|None] messages, list[str] comments, <a class="el" href="../../de/d59/classbabel_1_1messages_1_1extract_1_1__FileObj.html">_FileObj</a> fileobj, tuple[int|tuple[int, str],...] spec)</td></tr>
<tr class="separator:ae4b3ccc006cf228109406e3f3087032c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3ef13e5ea3445c85ebc7e5eeeba636" id="r_a6a3ef13e5ea3445c85ebc7e5eeeba636"><td class="memItemLeft" align="right" valign="top"><a id="a6a3ef13e5ea3445c85ebc7e5eeeba636" name="a6a3ef13e5ea3445c85ebc7e5eeeba636"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>_find_extractor</b> (str name)</td></tr>
<tr class="separator:a6a3ef13e5ea3445c85ebc7e5eeeba636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d6546b9dbf4a981f9741622700da9a" id="r_a99d6546b9dbf4a981f9741622700da9a"><td class="memItemLeft" align="right" valign="top">Generator[_ExtractionResult, None, None]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d0f/namespacebabel_1_1messages_1_1extract.html#a99d6546b9dbf4a981f9741622700da9a">extract</a> (_ExtractionMethod method, <a class="el" href="../../de/d59/classbabel_1_1messages_1_1extract_1_1__FileObj.html">_FileObj</a> fileobj, Mapping[str, _Keyword] keywords=DEFAULT_KEYWORDS, Collection[str] comment_tags=(), Mapping[str, Any]|None options=None, bool strip_comment_tags=False)</td></tr>
<tr class="separator:a99d6546b9dbf4a981f9741622700da9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae913b45f59516bdfe6d9f381c5ffc99b" id="r_ae913b45f59516bdfe6d9f381c5ffc99b"><td class="memItemLeft" align="right" valign="top">list[_ExtractionResult]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d0f/namespacebabel_1_1messages_1_1extract.html#ae913b45f59516bdfe6d9f381c5ffc99b">extract_nothing</a> (<a class="el" href="../../de/d59/classbabel_1_1messages_1_1extract_1_1__FileObj.html">_FileObj</a> fileobj, Mapping[str, _Keyword] keywords, Collection[str] comment_tags, Mapping[str, Any] options)</td></tr>
<tr class="separator:ae913b45f59516bdfe6d9f381c5ffc99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc553cd56d822da3986c00d88ed6796" id="r_aabc553cd56d822da3986c00d88ed6796"><td class="memItemLeft" align="right" valign="top">Generator[_ExtractionResult, None, None]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d0f/namespacebabel_1_1messages_1_1extract.html#aabc553cd56d822da3986c00d88ed6796">extract_python</a> (IO[bytes] fileobj, Mapping[str, _Keyword] keywords, Collection[str] comment_tags, <a class="el" href="../../d9/d69/classbabel_1_1messages_1_1extract_1_1__PyOptions.html">_PyOptions</a> options)</td></tr>
<tr class="separator:aabc553cd56d822da3986c00d88ed6796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48a4816b5b1d6f4e6f8c5ab6504199b" id="r_ae48a4816b5b1d6f4e6f8c5ab6504199b"><td class="memItemLeft" align="right" valign="top"><a id="ae48a4816b5b1d6f4e6f8c5ab6504199b" name="ae48a4816b5b1d6f4e6f8c5ab6504199b"></a>
str|None&#160;</td><td class="memItemRight" valign="bottom"><b>_parse_python_string</b> (str value, str encoding, int future_flags)</td></tr>
<tr class="separator:ae48a4816b5b1d6f4e6f8c5ab6504199b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c399388161eeed2f6e38730df3b450b" id="r_a0c399388161eeed2f6e38730df3b450b"><td class="memItemLeft" align="right" valign="top">Generator[_ExtractionResult, None, None]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d0f/namespacebabel_1_1messages_1_1extract.html#a0c399388161eeed2f6e38730df3b450b">extract_javascript</a> (<a class="el" href="../../de/d59/classbabel_1_1messages_1_1extract_1_1__FileObj.html">_FileObj</a> fileobj, Mapping[str, _Keyword] keywords, Collection[str] comment_tags, <a class="el" href="../../d0/d8a/classbabel_1_1messages_1_1extract_1_1__JSOptions.html">_JSOptions</a> options, int lineno=1)</td></tr>
<tr class="separator:a0c399388161eeed2f6e38730df3b450b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39bf4d58c6f97c11e8f1c69ee1c1950" id="r_ac39bf4d58c6f97c11e8f1c69ee1c1950"><td class="memItemLeft" align="right" valign="top">Generator[_ExtractionResult, None, None]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d0f/namespacebabel_1_1messages_1_1extract.html#ac39bf4d58c6f97c11e8f1c69ee1c1950">parse_template_string</a> (str template_string, Mapping[str, _Keyword] keywords, Collection[str] comment_tags, <a class="el" href="../../d0/d8a/classbabel_1_1messages_1_1extract_1_1__JSOptions.html">_JSOptions</a> options, int lineno=1)</td></tr>
<tr class="separator:ac39bf4d58c6f97c11e8f1c69ee1c1950"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7c02909de90bf87ee0af9538eb5b0362" id="r_a7c02909de90bf87ee0af9538eb5b0362"><td class="memItemLeft" align="right" valign="top"><a id="a7c02909de90bf87ee0af9538eb5b0362" name="a7c02909de90bf87ee0af9538eb5b0362"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TypeAlias</b></td></tr>
<tr class="separator:a7c02909de90bf87ee0af9538eb5b0362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71466c9f8ca8e9201c3246b204679b4a" id="r_a71466c9f8ca8e9201c3246b204679b4a"><td class="memItemLeft" align="right" valign="top"><a id="a71466c9f8ca8e9201c3246b204679b4a" name="a71466c9f8ca8e9201c3246b204679b4a"></a>
TypeAlias&#160;</td><td class="memItemRight" valign="bottom"><b>_Keyword</b> = dict[int | None, _SimpleKeyword] | _SimpleKeyword</td></tr>
<tr class="separator:a71466c9f8ca8e9201c3246b204679b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44326f484c7658fc0903b855f7f5c703" id="r_a44326f484c7658fc0903b855f7f5c703"><td class="memItemLeft" align="right" valign="top"><a id="a44326f484c7658fc0903b855f7f5c703" name="a44326f484c7658fc0903b855f7f5c703"></a>
TypeAlias&#160;</td><td class="memItemRight" valign="bottom"><b>_FileExtractionResult</b> = tuple[str, int, str | tuple[str, ...], list[str], str | None]</td></tr>
<tr class="separator:a44326f484c7658fc0903b855f7f5c703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf7d25dc4cf9f55118e5960282c7e96" id="r_aecf7d25dc4cf9f55118e5960282c7e96"><td class="memItemLeft" align="right" valign="top"><a id="aecf7d25dc4cf9f55118e5960282c7e96" name="aecf7d25dc4cf9f55118e5960282c7e96"></a>
TypeAlias&#160;</td><td class="memItemRight" valign="bottom"><b>_ExtractionResult</b> = tuple[int, str | tuple[str, ...], list[str], str | None]</td></tr>
<tr class="separator:aecf7d25dc4cf9f55118e5960282c7e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23dfa5efa4170e98a4667617bb2d8332" id="r_a23dfa5efa4170e98a4667617bb2d8332"><td class="memItemLeft" align="right" valign="top">TypeAlias&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d0f/namespacebabel_1_1messages_1_1extract.html#a23dfa5efa4170e98a4667617bb2d8332">_CallableExtractionMethod</a></td></tr>
<tr class="separator:a23dfa5efa4170e98a4667617bb2d8332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37c0294362c8d62a26b102af27d6f2c" id="r_ab37c0294362c8d62a26b102af27d6f2c"><td class="memItemLeft" align="right" valign="top"><a id="ab37c0294362c8d62a26b102af27d6f2c" name="ab37c0294362c8d62a26b102af27d6f2c"></a>
TypeAlias&#160;</td><td class="memItemRight" valign="bottom"><b>_ExtractionMethod</b> = _CallableExtractionMethod | str</td></tr>
<tr class="separator:ab37c0294362c8d62a26b102af27d6f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0abc390c0ec39d3ec9f6aecca022611" id="r_ae0abc390c0ec39d3ec9f6aecca022611"><td class="memItemLeft" align="right" valign="top"><a id="ae0abc390c0ec39d3ec9f6aecca022611" name="ae0abc390c0ec39d3ec9f6aecca022611"></a>
Final&#160;</td><td class="memItemRight" valign="bottom"><b>GROUP_NAME</b> = 'babel.extractors'</td></tr>
<tr class="separator:ae0abc390c0ec39d3ec9f6aecca022611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf20270552f066bd842ea108a6753ba" id="r_a5bf20270552f066bd842ea108a6753ba"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d0f/namespacebabel_1_1messages_1_1extract.html#a5bf20270552f066bd842ea108a6753ba">DEFAULT_KEYWORDS</a></td></tr>
<tr class="separator:a5bf20270552f066bd842ea108a6753ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e57c1363df38f359c0f1c8929025f5" id="r_a24e57c1363df38f359c0f1c8929025f5"><td class="memItemLeft" align="right" valign="top"><a id="a24e57c1363df38f359c0f1c8929025f5" name="a24e57c1363df38f359c0f1c8929025f5"></a>
list&#160;</td><td class="memItemRight" valign="bottom"><b>DEFAULT_MAPPING</b> = [('**.py', 'python')]</td></tr>
<tr class="separator:a24e57c1363df38f359c0f1c8929025f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff081731a59cee38ecc496683c1923e" id="r_aeff081731a59cee38ecc496683c1923e"><td class="memItemLeft" align="right" valign="top"><a id="aeff081731a59cee38ecc496683c1923e" name="aeff081731a59cee38ecc496683c1923e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FSTRING_START</b> = getattr(tokenize, &quot;FSTRING_START&quot;, None)</td></tr>
<tr class="separator:aeff081731a59cee38ecc496683c1923e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa172418d1c44ef42da99d75382e6ef60" id="r_aa172418d1c44ef42da99d75382e6ef60"><td class="memItemLeft" align="right" valign="top"><a id="aa172418d1c44ef42da99d75382e6ef60" name="aa172418d1c44ef42da99d75382e6ef60"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FSTRING_MIDDLE</b> = getattr(tokenize, &quot;FSTRING_MIDDLE&quot;, None)</td></tr>
<tr class="separator:aa172418d1c44ef42da99d75382e6ef60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b90844a9ca8d7accb4b2ce3497832d0" id="r_a1b90844a9ca8d7accb4b2ce3497832d0"><td class="memItemLeft" align="right" valign="top"><a id="a1b90844a9ca8d7accb4b2ce3497832d0" name="a1b90844a9ca8d7accb4b2ce3497832d0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FSTRING_END</b> = getattr(tokenize, &quot;FSTRING_END&quot;, None)</td></tr>
<tr class="separator:a1b90844a9ca8d7accb4b2ce3497832d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5527900af9f38ee8f607f3c904fe15c" id="r_aa5527900af9f38ee8f607f3c904fe15c"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d0f/namespacebabel_1_1messages_1_1extract.html#aa5527900af9f38ee8f607f3c904fe15c">_BUILTIN_EXTRACTORS</a></td></tr>
<tr class="separator:aa5527900af9f38ee8f607f3c904fe15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">    babel.messages.extract
    ~~~~~~~~~~~~~~~~~~~~~~

    Basic infrastructure for extracting localizable messages from source files.

    This module defines an extensible system for collecting localizable message
    strings from a variety of sources. A native extractor for Python source
    files is builtin, extractors for other sources can be added using very
    simple plugins.

    The main entry points into the extraction functionality are the functions
    `extract_from_dir` and `extract_from_file`.

    :copyright: (c) 2013-2025 by the Babel Team.
    :license: BSD, see LICENSE for more details.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="aed7e3a204b2e7b83645eb164c83ce324" name="aed7e3a204b2e7b83645eb164c83ce324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed7e3a204b2e7b83645eb164c83ce324">&#9670;&#160;</a></span>_strip_comment_tags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">babel.messages.extract._strip_comment_tags </td>
          <td>(</td>
          <td class="paramtype">MutableSequence[str]&#160;</td>
          <td class="paramname"><em>comments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable[str]&#160;</td>
          <td class="paramname"><em>tags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Helper function for `extract` that strips comment tags from strings
in a list of comment lines.  This functions operates in-place.
</pre> 
</div>
</div>
<a id="a34b58e48d2db9b0c09ba8d7144d65f82" name="a34b58e48d2db9b0c09ba8d7144d65f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b58e48d2db9b0c09ba8d7144d65f82">&#9670;&#160;</a></span>check_and_call_extract_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Generator[_FileExtractionResult, None, None] babel.messages.extract.check_and_call_extract_file </td>
          <td>(</td>
          <td class="paramtype">str | os.PathLike[str]&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable[tuple[str, str]]&#160;</td>
          <td class="paramname"><em>method_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SupportsItems[str, dict[str, Any]]&#160;</td>
          <td class="paramname"><em>options_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[[str, str, dict[str, Any]], object] | None&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mapping[str, _Keyword]&#160;</td>
          <td class="paramname"><em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Collection[str]&#160;</td>
          <td class="paramname"><em>comment_tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strip_comment_tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | os.PathLike[str] | None &#160;</td>
          <td class="paramname"><em>dirpath</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks if the given file matches an extraction method mapping, and if so, calls extract_from_file.

Note that the extraction method mappings are based relative to dirpath.
So, given an absolute path to a file `filepath`, we want to check using
just the relative path from `dirpath` to `filepath`.

Yields 5-tuples (filename, lineno, messages, comments, context).

:param filepath: An absolute path to a file that exists.
:param method_map: a list of ``(pattern, method)`` tuples that maps of
                   extraction method names to extended glob patterns
:param options_map: a dictionary of additional options (optional)
:param callback: a function that is called for every file that message are
                 extracted from, just before the extraction itself is
                 performed; the function is passed the filename, the name
                 of the extraction method and and the options dictionary as
                 positional arguments, in that order
:param keywords: a dictionary mapping keywords (i.e. names of functions
                 that should be recognized as translation functions) to
                 tuples that specify which of their arguments contain
                 localizable strings
:param comment_tags: a list of tags of translator comments to search for
                     and include in the results
:param strip_comment_tags: a flag that if set to `True` causes all comment
                           tags to be removed from the collected comments.
:param dirpath: the path to the directory to extract messages from.
:return: iterable of 5-tuples (filename, lineno, messages, comments, context)
:rtype: Iterable[tuple[str, int, str|tuple[str], list[str], str|None]
</pre> 
</div>
</div>
<a id="a99d6546b9dbf4a981f9741622700da9a" name="a99d6546b9dbf4a981f9741622700da9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d6546b9dbf4a981f9741622700da9a">&#9670;&#160;</a></span>extract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Generator[_ExtractionResult, None, None] babel.messages.extract.extract </td>
          <td>(</td>
          <td class="paramtype">_ExtractionMethod&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/d59/classbabel_1_1messages_1_1extract_1_1__FileObj.html">_FileObj</a>&#160;</td>
          <td class="paramname"><em>fileobj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mapping[str, _Keyword] &#160;</td>
          <td class="paramname"><em>keywords</em> = <code>DEFAULT_KEYWORDS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Collection[str] &#160;</td>
          <td class="paramname"><em>comment_tags</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mapping[str, Any] | None &#160;</td>
          <td class="paramname"><em>options</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>strip_comment_tags</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Extract messages from the given file-like object using the specified
extraction method.

This function returns tuples of the form ``(lineno, message, comments, context)``.

The implementation dispatches the actual extraction to plugins, based on the
value of the ``method`` parameter.

&gt;&gt;&gt; source = b'''# foo module
... def run(argv):
...    print(_('Hello, world!'))
... '''

&gt;&gt;&gt; from io import BytesIO
&gt;&gt;&gt; for message in extract('python', BytesIO(source)):
...     print(message)
(3, u'Hello, world!', [], None)

:param method: an extraction method (a callable), or
               a string specifying the extraction method (.e.g. "python");
               if this is a simple name, the extraction function will be
               looked up by entry point; if it is an explicit reference
               to a function (of the form ``package.module:funcname`` or
               ``package.module.funcname``), the corresponding function
               will be imported and used
:param fileobj: the file-like object the messages should be extracted from
:param keywords: a dictionary mapping keywords (i.e. names of functions
                 that should be recognized as translation functions) to
                 tuples that specify which of their arguments contain
                 localizable strings
:param comment_tags: a list of translator tags to search for and include
                     in the results
:param options: a dictionary of additional options (optional)
:param strip_comment_tags: a flag that if set to `True` causes all comment
                           tags to be removed from the collected comments.
:raise ValueError: if the extraction method is not registered
:returns: iterable of tuples of the form ``(lineno, message, comments, context)``
:rtype: Iterable[tuple[int, str|tuple[str], list[str], str|None]
</pre> 
</div>
</div>
<a id="ad058b4dfa640166376e8560b0fcbcb3b" name="ad058b4dfa640166376e8560b0fcbcb3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad058b4dfa640166376e8560b0fcbcb3b">&#9670;&#160;</a></span>extract_from_dir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Generator[_FileExtractionResult, None, None] babel.messages.extract.extract_from_dir </td>
          <td>(</td>
          <td class="paramtype">str | os.PathLike[str] | None &#160;</td>
          <td class="paramname"><em>dirname</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable[tuple[str, str]] &#160;</td>
          <td class="paramname"><em>method_map</em> = <code>DEFAULT_MAPPING</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SupportsItems[str, dict[str, Any]] | None &#160;</td>
          <td class="paramname"><em>options_map</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mapping[str, _Keyword] &#160;</td>
          <td class="paramname"><em>keywords</em> = <code>DEFAULT_KEYWORDS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Collection[str] &#160;</td>
          <td class="paramname"><em>comment_tags</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[[str, str, dict[str, Any]], object] | None &#160;</td>
          <td class="paramname"><em>callback</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>strip_comment_tags</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[[str], bool] | None &#160;</td>
          <td class="paramname"><em>directory_filter</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Extract messages from any source files found in the given directory.

This function generates tuples of the form ``(filename, lineno, message,
comments, context)``.

Which extraction method is used per file is determined by the `method_map`
parameter, which maps extended glob patterns to extraction method names.
For example, the following is the default mapping:

&gt;&gt;&gt; method_map = [
...     ('**.py', 'python')
... ]

This basically says that files with the filename extension ".py" at any
level inside the directory should be processed by the "python" extraction
method. Files that don't match any of the mapping patterns are ignored. See
the documentation of the `pathmatch` function for details on the pattern
syntax.

The following extended mapping would also use the "genshi" extraction
method on any file in "templates" subdirectory:

&gt;&gt;&gt; method_map = [
...     ('**/templates/**.*', 'genshi'),
...     ('**.py', 'python')
... ]

The dictionary provided by the optional `options_map` parameter augments
these mappings. It uses extended glob patterns as keys, and the values are
dictionaries mapping options names to option values (both strings).

The glob patterns of the `options_map` do not necessarily need to be the
same as those used in the method mapping. For example, while all files in
the ``templates`` folders in an application may be Genshi applications, the
options for those files may differ based on extension:

&gt;&gt;&gt; options_map = {
...     '**/templates/**.txt': {
...         'template_class': 'genshi.template:TextTemplate',
...         'encoding': 'latin-1'
...     },
...     '**/templates/**.html': {
...         'include_attrs': ''
...     }
... }

:param dirname: the path to the directory to extract messages from.  If
                not given the current working directory is used.
:param method_map: a list of ``(pattern, method)`` tuples that maps of
                   extraction method names to extended glob patterns
:param options_map: a dictionary of additional options (optional)
:param keywords: a dictionary mapping keywords (i.e. names of functions
                 that should be recognized as translation functions) to
                 tuples that specify which of their arguments contain
                 localizable strings
:param comment_tags: a list of tags of translator comments to search for
                     and include in the results
:param callback: a function that is called for every file that message are
                 extracted from, just before the extraction itself is
                 performed; the function is passed the filename, the name
                 of the extraction method and and the options dictionary as
                 positional arguments, in that order
:param strip_comment_tags: a flag that if set to `True` causes all comment
                           tags to be removed from the collected comments.
:param directory_filter: a callback to determine whether a directory should
                         be recursed into. Receives the full directory path;
                         should return True if the directory is valid.
:see: `pathmatch`
</pre> 
</div>
</div>
<a id="a862f8e2ef602348b174346a22e9fc89e" name="a862f8e2ef602348b174346a22e9fc89e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862f8e2ef602348b174346a22e9fc89e">&#9670;&#160;</a></span>extract_from_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> list[_ExtractionResult] babel.messages.extract.extract_from_file </td>
          <td>(</td>
          <td class="paramtype">_ExtractionMethod&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | os.PathLike[str]&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mapping[str, _Keyword] &#160;</td>
          <td class="paramname"><em>keywords</em> = <code>DEFAULT_KEYWORDS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Collection[str] &#160;</td>
          <td class="paramname"><em>comment_tags</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mapping[str, Any] | None &#160;</td>
          <td class="paramname"><em>options</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>strip_comment_tags</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Extract messages from a specific file.

This function returns a list of tuples of the form ``(lineno, message, comments, context)``.

:param filename: the path to the file to extract messages from
:param method: a string specifying the extraction method (.e.g. "python")
:param keywords: a dictionary mapping keywords (i.e. names of functions
                 that should be recognized as translation functions) to
                 tuples that specify which of their arguments contain
                 localizable strings
:param comment_tags: a list of translator tags to search for and include
                     in the results
:param strip_comment_tags: a flag that if set to `True` causes all comment
                           tags to be removed from the collected comments.
:param options: a dictionary of additional options (optional)
:returns: list of tuples of the form ``(lineno, message, comments, context)``
:rtype: list[tuple[int, str|tuple[str], list[str], str|None]
</pre> 
</div>
</div>
<a id="a0c399388161eeed2f6e38730df3b450b" name="a0c399388161eeed2f6e38730df3b450b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c399388161eeed2f6e38730df3b450b">&#9670;&#160;</a></span>extract_javascript()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Generator[_ExtractionResult, None, None] babel.messages.extract.extract_javascript </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d59/classbabel_1_1messages_1_1extract_1_1__FileObj.html">_FileObj</a>&#160;</td>
          <td class="paramname"><em>fileobj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mapping[str, _Keyword]&#160;</td>
          <td class="paramname"><em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Collection[str]&#160;</td>
          <td class="paramname"><em>comment_tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d8a/classbabel_1_1messages_1_1extract_1_1__JSOptions.html">_JSOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>lineno</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Extract messages from JavaScript source code.

:param fileobj: the seekable, file-like object the messages should be
                extracted from
:param keywords: a list of keywords (i.e. function names) that should be
                 recognized as translation functions
:param comment_tags: a list of translator tags to search for and include
                     in the results
:param options: a dictionary of additional options (optional)
                Supported options are:
                * `jsx` -- set to false to disable JSX/E4X support.
                * `template_string` -- if `True`, supports gettext(`key`)
                * `parse_template_string` -- if `True` will parse the
                                             contents of javascript
                                             template strings.
:param lineno: line number offset (for parsing embedded fragments)
</pre> 
</div>
</div>
<a id="ae913b45f59516bdfe6d9f381c5ffc99b" name="ae913b45f59516bdfe6d9f381c5ffc99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae913b45f59516bdfe6d9f381c5ffc99b">&#9670;&#160;</a></span>extract_nothing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> list[_ExtractionResult] babel.messages.extract.extract_nothing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d59/classbabel_1_1messages_1_1extract_1_1__FileObj.html">_FileObj</a>&#160;</td>
          <td class="paramname"><em>fileobj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mapping[str, _Keyword]&#160;</td>
          <td class="paramname"><em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Collection[str]&#160;</td>
          <td class="paramname"><em>comment_tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mapping[str, Any]&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Pseudo extractor that does not actually extract anything, but simply
returns an empty list.
</pre> 
</div>
</div>
<a id="aabc553cd56d822da3986c00d88ed6796" name="aabc553cd56d822da3986c00d88ed6796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabc553cd56d822da3986c00d88ed6796">&#9670;&#160;</a></span>extract_python()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Generator[_ExtractionResult, None, None] babel.messages.extract.extract_python </td>
          <td>(</td>
          <td class="paramtype">IO[bytes]&#160;</td>
          <td class="paramname"><em>fileobj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mapping[str, _Keyword]&#160;</td>
          <td class="paramname"><em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Collection[str]&#160;</td>
          <td class="paramname"><em>comment_tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d69/classbabel_1_1messages_1_1extract_1_1__PyOptions.html">_PyOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Extract messages from Python source code.

It returns an iterator yielding tuples in the following form ``(lineno,
funcname, message, comments)``.

:param fileobj: the seekable, file-like object the messages should be
                extracted from
:param keywords: a list of keywords (i.e. function names) that should be
                 recognized as translation functions
:param comment_tags: a list of translator tags to search for and include
                     in the results
:param options: a dictionary of additional options (optional)
:rtype: ``iterator``
</pre> 
</div>
</div>
<a id="ac39bf4d58c6f97c11e8f1c69ee1c1950" name="ac39bf4d58c6f97c11e8f1c69ee1c1950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39bf4d58c6f97c11e8f1c69ee1c1950">&#9670;&#160;</a></span>parse_template_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Generator[_ExtractionResult, None, None] babel.messages.extract.parse_template_string </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>template_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mapping[str, _Keyword]&#160;</td>
          <td class="paramname"><em>keywords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Collection[str]&#160;</td>
          <td class="paramname"><em>comment_tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d8a/classbabel_1_1messages_1_1extract_1_1__JSOptions.html">_JSOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>lineno</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parse JavaScript template string.

:param template_string: the template string to be parsed
:param keywords: a list of keywords (i.e. function names) that should be
                 recognized as translation functions
:param comment_tags: a list of translator tags to search for and include
                     in the results
:param options: a dictionary of additional options (optional)
:param lineno: starting line number (optional)
</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aa5527900af9f38ee8f607f3c904fe15c" name="aa5527900af9f38ee8f607f3c904fe15c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5527900af9f38ee8f607f3c904fe15c">&#9670;&#160;</a></span>_BUILTIN_EXTRACTORS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dict babel.messages.extract._BUILTIN_EXTRACTORS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {</div>
<div class="line"><span class="lineno">    2</span>    <span class="stringliteral">&#39;ignore&#39;</span>: extract_nothing,</div>
<div class="line"><span class="lineno">    3</span>    <span class="stringliteral">&#39;python&#39;</span>: extract_python,</div>
<div class="line"><span class="lineno">    4</span>    <span class="stringliteral">&#39;javascript&#39;</span>: extract_javascript,</div>
<div class="line"><span class="lineno">    5</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a23dfa5efa4170e98a4667617bb2d8332" name="a23dfa5efa4170e98a4667617bb2d8332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23dfa5efa4170e98a4667617bb2d8332">&#9670;&#160;</a></span>_CallableExtractionMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TypeAlias babel.messages.extract._CallableExtractionMethod</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  Callable[</div>
<div class="line"><span class="lineno">    2</span>        [_FileObj | IO[bytes], Mapping[str, _Keyword], Collection[str], Mapping[str, Any]],</div>
<div class="line"><span class="lineno">    3</span>        Iterable[_ExtractionResult],</div>
<div class="line"><span class="lineno">    4</span>    ]</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5bf20270552f066bd842ea108a6753ba" name="a5bf20270552f066bd842ea108a6753ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf20270552f066bd842ea108a6753ba">&#9670;&#160;</a></span>DEFAULT_KEYWORDS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dict babel.messages.extract.DEFAULT_KEYWORDS</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {</div>
<div class="line"><span class="lineno">    2</span>    <span class="stringliteral">&#39;_&#39;</span>: <span class="keywordtype">None</span>,</div>
<div class="line"><span class="lineno">    3</span>    <span class="stringliteral">&#39;gettext&#39;</span>: <span class="keywordtype">None</span>,</div>
<div class="line"><span class="lineno">    4</span>    <span class="stringliteral">&#39;ngettext&#39;</span>: (1, 2),</div>
<div class="line"><span class="lineno">    5</span>    <span class="stringliteral">&#39;ugettext&#39;</span>: <span class="keywordtype">None</span>,</div>
<div class="line"><span class="lineno">    6</span>    <span class="stringliteral">&#39;ungettext&#39;</span>: (1, 2),</div>
<div class="line"><span class="lineno">    7</span>    <span class="stringliteral">&#39;dgettext&#39;</span>: (2,),</div>
<div class="line"><span class="lineno">    8</span>    <span class="stringliteral">&#39;dngettext&#39;</span>: (2, 3),</div>
<div class="line"><span class="lineno">    9</span>    <span class="stringliteral">&#39;N_&#39;</span>: <span class="keywordtype">None</span>,</div>
<div class="line"><span class="lineno">   10</span>    <span class="stringliteral">&#39;pgettext&#39;</span>: ((1, <span class="stringliteral">&#39;c&#39;</span>), 2),</div>
<div class="line"><span class="lineno">   11</span>    <span class="stringliteral">&#39;npgettext&#39;</span>: ((1, <span class="stringliteral">&#39;c&#39;</span>), 2, 3),</div>
<div class="line"><span class="lineno">   12</span>}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
